import * as fs from "fs";
import jetpack from "fs-jetpack";
import path from "path";
import type {Plugin, ViteDevServer} from "vite";
import {type ResolvedConfig} from 'vite';
import {MagicString, relativeify, walk} from "vite-plugin-utils/function";
import {Context} from "./Generator";
import {infoLog} from "./Logger";
import {defaultPluginConfig, type FullConfig, type PluginConfig} from "./types";
import type {AcornNode as AcornNode2} from 'rollup';

export type AcornNode<T = any> = AcornNode2 & Record<string, T>


const pluginConfig: Partial<FullConfig> = {
	projectRoot          : null,
	projectRootDirectory : null,
	storesPath           : null,
	storesDirectory      : null,
	storesFileName       : null,

	...defaultPluginConfig,
};

const storeNameRegex = /(Store|store)\.ts$/;


export function ClassStoresPlugin(configuration?: PluginConfig): Plugin {
	for (let configurationKey in configuration) {
		if (configuration[configurationKey]) {
			pluginConfig[configurationKey] = configuration[configurationKey];
		}
	}

	let viteConfig: ResolvedConfig;
	let server: ViteDevServer;

	const context = new Context();

	return {
		name : 'class-stores-loader',

		async configResolved(config) {
			pluginConfig.projectRoot          = config.root;
			pluginConfig.storesPath           = path.resolve(pluginConfig.projectRoot, pluginConfig.storesPath);
			pluginConfig.storesDirectory      = jetpack.cwd(pluginConfig.storesPath);
			pluginConfig.projectRootDirectory = jetpack.cwd(pluginConfig.projectRoot);

			viteConfig = config;

			context.init(pluginConfig);
			context.process();
		},
		configureServer(devServer) {
			server = devServer;
			server.watcher.on('all', (eventName: 'add' | 'change' | 'unlink', filePath: string, stats?: fs.Stats) => {
				if (!['add', 'change', 'unlink'].includes(eventName)) {
					return;
				}

				if (isGeneratedFilePath(filePath)) {
					return;
				}
				if (!filePath.startsWith(pluginConfig.storesPath)) {
					return;
				}

				context.reloadModules();

				if (['change', 'unlink'].includes(eventName)) {
					const store = context.getStoreByFilePath(filePath);
					if (!store) {
						return;
					}

					eventName === 'unlink'
						? infoLog(`Store file deletion detected: ${store.className}`)
						: infoLog(`Store file change detected: ${store.className}`);

					infoLog(`Rebuilding stores...`);
					context.rebuild();

					return;
				}


				let store = context.getStoreByFilePath(filePath);
				if (!store) {
					infoLog(`New file detected: ${filePath}`);
					infoLog(`Rebuilding store meta...`);
					context.process();
				}
				// Just to ensure it was actually a new store, not a random file
				store = context.getStoreByFilePath(filePath);
				if (store) {
					infoLog(`Addition was a new store: ${store.className}`);
					infoLog(`Rebuilding stores...`);
					context.rebuild();
				}

			});
		},

		async transform(code, id) {
			if (/node_modules\/(?!\.vite\/)/.test(id)) return;
			if (!id.endsWith('.ts')) return;

			const ast = this.parse(code);
			const ms  = new MagicString(code);

			await walk(ast, {
				CallExpression(node: AcornNode) {
					if (node.callee?.type !== 'MemberExpression') return;

					/**
					 * Transform app.use(StoreManager.boot()) to
					 * app.use(StoreManager.boot(import.meta.glob('./Stores/Generated/StoreLoader.ts', {eager:true})))
					 */

					const expression = node.callee;
					if (expression.object?.type !== 'Identifier') return;
					if (expression.object?.name !== 'StoreManager') return;
					if (expression.property?.type !== 'Identifier') return;
					if (expression.property?.name !== 'boot') return;
					if (!!node?.arguments?.length) return;

					const statementCode    = code.slice(node.start, node.end);
					const loaderImportPath = relativeify(path.relative(path.dirname(id), pluginConfig.storesDirectory.path(
						pluginConfig.generatedDirName,
						pluginConfig.storeLoaderFile
					)));

					const newStatement = `StoreManager.boot(import.meta.glob('${loaderImportPath}', {eager:true}))`;

					infoLog(`Transformed boot call from "${statementCode}" to "${newStatement}"`);

					ms.overwrite(node.start, node.end, newStatement);
				}
			});

			const msResult = ms.toString();
			if (msResult === code) return;

			return msResult;
		},
		buildStart(options: any) {
			context.writeFiles();
		},
	};
}


/**
 * Checks if the specified file is one that's generated by the plugin.
 * This is used within things like the HMR handler to prevent infinite loops.
 * @param {string} file
 */
function isGeneratedFilePath(file: string) {
	const paths = [
		pluginConfig.storesDirectory.path(pluginConfig.storesFileName),
	];
	return paths.includes(file);
}
